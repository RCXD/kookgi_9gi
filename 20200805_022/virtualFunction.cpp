#include "config.h"

//	c++은 컴파일시 별도의 설정이 없으면 기본적으로 정적 바인딩을 수행한다. <=> 동적 바인딩
//	정적 바인딩은 클래스 객체가 실행할 함수의 주소가 컴파일 단계에서 결정된다. => 프로그램 실행중에 변경할 수 없다.
//	정적 바인딩 방식으로 컴파일된 프로그램 실행중에 함수를 실행할 객체의 주소가 변경되더라도 실제 실행하는 함수는 컴파일 단계에서 결정된
//	함수를 실행한다.

//	함수를 선언할 때 "virtual" 예약어를 붙여서 선언하면 동적 바인딩을 수행한다.
//	동적 바인딩은 컴파일 단계에서는 객체가 실행할 함수의 주소 부분을 비워두고 컴파일하고 실행 단계에서 실행할 함수의 주소가 결정되면
//	비워두었던 주소 부분을 채워서 함수를 실행한다.

class Base {
public:
	void virtual toString() {	// 가상 함수 => 동적 바인딩
		cout << "부모(Base) 클래스의 toString() 함수 실행" << endl;
	}
};

class Sub : public Base {
public:
	void toString() {			// 일반 함수 => 정적 바인딩
		cout << "서브(Sub) 클래스의 toString() 함수 실행" << endl;
	}
};

void main() {

	Base base, * pBase;
	base.toString();
	pBase = &base;
	pBase->toString();
	cout << "포인터 변수 pBase에 저장된 주소 => base가 메모리에 생성된 주소 : " << pBase << endl;
	cout << "============================================================================" << endl;

	Sub sub, * pSub;
	sub.toString();
	pSub = &sub;
	pSub->toString();
	cout << "포인터 변수 pSub에 저장된 주소 => sub가 메모리에 생성된 주소 : " << pSub << endl;
	cout << "============================================================================" << endl;

//	결론 => 부모 클래스 타입으로 자식 클래스 타입의 객체를 제어할 수 있지만 자식 클래스 타입으로 부모 클래스 타입의 객체를 제어할 수 없다.
//	pSub = pBase;			// 자식 클래스 타입에 부모 클래스 타입을 대입했으므로 에러가 발생된다.
//	pSub = new Base();		// 자식 클래스 타입에 부모 클래스 타입을 대입했으므로 에러가 발생된다.

//	부모 클래스 타입의 포인터 변수에 자식 클래스 타입의 포인터 변수에 저장된 주소를 넣어준다.
	pBase = pSub;
//	pBase = new Sub();

	cout << "포인터 변수 pBase에 저장된 주소 : " << pBase << endl;
	pBase->toString();

}